[{"content":"mutex是什么 mutex是golang中处理异步状态的工具 有互斥锁 sync.Mutex 和读写锁 sync.RWMutex\n互斥锁和读写锁的区别 读写锁本身内部实现就是用来互斥锁的技术 互斥锁是简单意义上的上锁开锁概念，且不支持多次上锁 会报错。 读写锁是在互斥锁的基础上封装了业务逻辑，即 允许多次读锁的上锁和开锁 待到读锁都释放时方能运行写锁上锁 写锁上锁时，不允许读锁使用 概念说明 自旋条件: 未获取到锁时循环获取,有次数限制 超过次数进入唤醒队列进行等待 饥饿状态: 竞争状态下老goroutine长时间未获取到锁就会进入饥饿状态,取消自旋机制，采用FIFO 先进先出的办法处理等待队列 正常状态: 非饥饿状态，等待队列的原则是先进先出。若有自旋状态的goroutine则相互竞争获取锁 结构体 //互斥锁 type Mutex struct { state int32 //状态标志位 通过原子操作进行修改 sema uint32 //信号量，用于使用goroutine的阻塞和唤醒 } // state状态标志位实际上是用多个位的状态来进行区分(如下所示,x表示0/1) // xxxxxx... x x x // goroutine排队个数 是否饥饿状态 是否有协程被唤醒 是否上锁 //读写锁 type RWMutex struct { w Mutex // 互斥锁的原理 writerSem uint32 // 写协程的信号量 readerSem uint32 // 读协程的信号量 readerCount int32 // number of pending readers readerWait int32 // number of departing readers } ","permalink":"https://thebestll.github.io/2023/lock/","summary":"mutex是什么 mutex是golang中处理异步状态的工具 有互斥锁 sync.Mutex 和读写锁 sync.RWMutex\n互斥锁和读写锁的区别 读写锁本身内部实现就是用来互斥锁的技术 互斥锁是简单意义上的上锁开锁概念，且不支持多次上锁 会报错。 读写锁是在互斥锁的基础上封装了业务逻辑，即 允许多次读锁的上锁和开锁 待到读锁都释放时方能运行写锁上锁 写锁上锁时，不允许读锁使用 概念说明 自旋条件: 未获取到锁时循环获取,有次数限制 超过次数进入唤醒队列进行等待 饥饿状态: 竞争状态下老goroutine长时间未获取到锁就会进入饥饿状态,取消自旋机制，采用FIFO 先进先出的办法处理等待队列 正常状态: 非饥饿状态，等待队列的原则是先进先出。若有自旋状态的goroutine则相互竞争获取锁 结构体 //互斥锁 type Mutex struct { state int32 //状态标志位 通过原子操作进行修改 sema uint32 //信号量，用于使用goroutine的阻塞和唤醒 } // state状态标志位实际上是用多个位的状态来进行区分(如下所示,x表示0/1) // xxxxxx... x x x // goroutine排队个数 是否饥饿状态 是否有协程被唤醒 是否上锁 //读写锁 type RWMutex struct { w Mutex // 互斥锁的原理 writerSem uint32 // 写协程的信号量 readerSem uint32 // 读协程的信号量 readerCount int32 // number of pending readers readerWait int32 // number of departing readers } ","title":"mutex"},{"content":"buffer是什么 一个实现了缓冲字节流的高效数据类型 buffer的存在意义 减少系统调用减少读写操作,常见于网络io和文件io中 内存使用优化 可以预定字节流大小 自动扩充字节切片 buffer重置时不需要使用新内存块，只需要重用字节切片即可 支持多种数据格式 支持并发读写 buffer具体实现 //Go 1.19版本 type Buffer struct { buf []byte // 实际数据切片 包括 len(buf)长度和 cap(buf)容量 off int // 已读数据,或者是已写数据 lastRead readOp // 标志位，用于记录上一次操作状态 分为空状态、读状态、读一个字节、读俩个字节... ","permalink":"https://thebestll.github.io/2023/buffer/","summary":"buffer是什么 一个实现了缓冲字节流的高效数据类型 buffer的存在意义 减少系统调用减少读写操作,常见于网络io和文件io中 内存使用优化 可以预定字节流大小 自动扩充字节切片 buffer重置时不需要使用新内存块，只需要重用字节切片即可 支持多种数据格式 支持并发读写 buffer具体实现 //Go 1.19版本 type Buffer struct { buf []byte // 实际数据切片 包括 len(buf)长度和 cap(buf)容量 off int // 已读数据,或者是已写数据 lastRead readOp // 标志位，用于记录上一次操作状态 分为空状态、读状态、读一个字节、读俩个字节... ","title":"Buffer"},{"content":"chan是什么 chan是用于goroutine通信的重要方式 分为无缓冲通道和有缓冲通道俩种 并发安全,可以支持多取多给 chan的存在意义 简化了多协程环境通信的复杂性(并发安全、准确性、原子性\u0026hellip;) chan实现存在意义的方法 make定义的chan实际上是一个结构体的指针 在chan传递值的时候，实际上进行的是值拷贝 Do not comminute by sharing memory;instead, share memory by communicating 利用环形列表使得缓冲通道得以实现 利用互斥锁实现的读取堵塞 chan结构体 #源码位于 1.19版本runtime\\chan.go type hchan struct { qcount uint // chan长度 有缓存\u0026gt;1 无缓存=1 dataqsiz uint // 环形队列首部 buf unsafe.Pointer // 环形数据指针 elemsize uint16 // 环形队列尾部 closed uint32 elemtype *_type // chan数据类型 sendx uint // 发送 index recvx uint // 接收 index recvq waitq // 等待接收的 waiters sendq waitq // 等待发送的 waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G\u0026#39;s status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex //互斥锁 } chan接收\\发送数据的流程 make数据 testChan:=make(chan int,1) 或者无缓存 testChan:=make(chan int) 注意此时的testChan本质上是一个hchan指针 接收goroutine数据 testChan\u0026lt;-data 判断环形队列是否已经满了,即判断chan的环形队列尾索引值+1是整除总长度是否等于队列首索引值 (this.tail + 1) % this.maxSize == this.head 若队列未满，则上锁 sendx+1 将goroutine数据复制一份到队列中保存后, recv+1 再释放锁 若队列已满,则利用将goroutine加入 recvq队列中 中,并利用GMP调度,将替换当前执行的goroutine 队列有空间时,则启用recvq队列相应接收数据 向goroutine发送数据 data\u0026lt;-testChan 判断环形队列是否有数据,即判断chan环形队列的首尾索引是否相等 若队列有数据,则上锁 sendx+1 将队列数据复制一份到goroutine后, recv+1 再释放锁 若队列为空,则利用将goroutine加入 sendq队列中 中,并利用GMP调度,将替换当前执行的goroutine 待有数据到来到时,则启用sendq队列相应消费数据 ","permalink":"https://thebestll.github.io/2023/chan/","summary":"chan是什么 chan是用于goroutine通信的重要方式 分为无缓冲通道和有缓冲通道俩种 并发安全,可以支持多取多给 chan的存在意义 简化了多协程环境通信的复杂性(并发安全、准确性、原子性\u0026hellip;) chan实现存在意义的方法 make定义的chan实际上是一个结构体的指针 在chan传递值的时候，实际上进行的是值拷贝 Do not comminute by sharing memory;instead, share memory by communicating 利用环形列表使得缓冲通道得以实现 利用互斥锁实现的读取堵塞 chan结构体 #源码位于 1.19版本runtime\\chan.go type hchan struct { qcount uint // chan长度 有缓存\u0026gt;1 无缓存=1 dataqsiz uint // 环形队列首部 buf unsafe.Pointer // 环形数据指针 elemsize uint16 // 环形队列尾部 closed uint32 elemtype *_type // chan数据类型 sendx uint // 发送 index recvx uint // 接收 index recvq waitq // 等待接收的 waiters sendq waitq // 等待发送的 waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel.","title":"chan学习"},{"content":"自我介绍 Hello\n我叫车牛皮糖，96年出生。\n一个拥有可爱女儿的年轻爸爸,也是一个工龄4年半的安全研发。 我的想法很多,但是它们经常跑得也很快。\n从来没有得到真正反复淬炼和思考,所以我选择记录它并尝试分享。 分享得过程回让我喜悦,也是一次思想整理的过程。\n目前我在同程旅游工作，是全栈工程师(偏后端)。 关注的方向是 主机安全(小白) 和 AI(纯小白)。 如果您有兴趣一起来探讨技术上或者生活上的问题，可以通过微信联系到我。\nWechat Email 792501053@qq.com\n","permalink":"https://thebestll.github.io/aboutme/","summary":"自我介绍 Hello\n我叫车牛皮糖，96年出生。\n一个拥有可爱女儿的年轻爸爸,也是一个工龄4年半的安全研发。 我的想法很多,但是它们经常跑得也很快。\n从来没有得到真正反复淬炼和思考,所以我选择记录它并尝试分享。 分享得过程回让我喜悦,也是一次思想整理的过程。\n目前我在同程旅游工作，是全栈工程师(偏后端)。 关注的方向是 主机安全(小白) 和 AI(纯小白)。 如果您有兴趣一起来探讨技术上或者生活上的问题，可以通过微信联系到我。\nWechat Email 792501053@qq.com","title":"About Me"},{"content":"写在前面 虽然今年已经过去一半，但是任何时候启程都不算太晚 “也算是对抗焦虑的一剂良药”\n概述 自我总结 工作也好几年了，但是一直没有对自己掌握的知识做归纳总结。处于一个比较混乱的状态。\n未来的路 定好方向，才不会迷茫\n每一步 具体分步做好规划，做好持久战的准备\n自我总结 后端开发 go 主要在使用的开发语言,平台后端构建相关知识熟练,但是基础不牢 python 主要用于构建一些测试样例,解决实际小任务,水平 “简答会用” java 弱 前端开发 Vue 熟练掌握Vue2,存在Vue3开发经验 浏览器插件 有过一个项目的开发经验 electron 有过一个项目的开发经验 中间件 数据库 mysql 业务熟练，基础缺乏 mongo 业务熟练，基础缺乏 redis 业务熟练，基础缺乏 消息处理 kafka 业务熟练，基础缺乏 Es 业务熟练，基础缺乏 ETCD 业务熟练，基础缺乏 未来的路 考虑继续往安全开发岗位发展 目前尝试的太少 探索的太少\nstepToStep 专注于基础 2023-6-11 to 2023-7-30 go语言八股文学习 基本遵循 https://github.com/debuginn/golang-developer-roadmap-cn学习路线 命令行、信道、缓冲区、互斥锁 延迟机制、panic、Recover 对前端的学习，暂时处于能用就行 中间件基础学习 mysql、mongo、redis ","permalink":"https://thebestll.github.io/2023/plan/","summary":"写在前面 虽然今年已经过去一半，但是任何时候启程都不算太晚 “也算是对抗焦虑的一剂良药”\n概述 自我总结 工作也好几年了，但是一直没有对自己掌握的知识做归纳总结。处于一个比较混乱的状态。\n未来的路 定好方向，才不会迷茫\n每一步 具体分步做好规划，做好持久战的准备\n自我总结 后端开发 go 主要在使用的开发语言,平台后端构建相关知识熟练,但是基础不牢 python 主要用于构建一些测试样例,解决实际小任务,水平 “简答会用” java 弱 前端开发 Vue 熟练掌握Vue2,存在Vue3开发经验 浏览器插件 有过一个项目的开发经验 electron 有过一个项目的开发经验 中间件 数据库 mysql 业务熟练，基础缺乏 mongo 业务熟练，基础缺乏 redis 业务熟练，基础缺乏 消息处理 kafka 业务熟练，基础缺乏 Es 业务熟练，基础缺乏 ETCD 业务熟练，基础缺乏 未来的路 考虑继续往安全开发岗位发展 目前尝试的太少 探索的太少\nstepToStep 专注于基础 2023-6-11 to 2023-7-30 go语言八股文学习 基本遵循 https://github.com/debuginn/golang-developer-roadmap-cn学习路线 命令行、信道、缓冲区、互斥锁 延迟机制、panic、Recover 对前端的学习，暂时处于能用就行 中间件基础学习 mysql、mongo、redis ","title":"2023学习计划"}]